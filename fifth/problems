В первой задаче каждого варианта требуется выбрать представление и определить тип данных
data Map key value = ..
для которого требуется реализовать стандартный набор методов для манипуляций с “отображением”:
get :: Eq k => k -> Map k v -> Maybe v
put :: Eq k => (k, v) -> Map k v -> Map k v
remove :: Eq k => k -> Map k v -> Map k v
keys :: Map k v -> [k]
values :: Map k v -> [v]
Все вышеперечисленные функции имеют обычный для операций над отображениями смысл: найти значение по ключу (get), добавить или заменить существующую пару <ключ,значение> (put), удалить пару с заданным ключом (remove), выдать множество (список) всех ключей (keys) и выдать список всех значений (values). Не следует сильно заботиться об эффективности представления и скорости работы функций, например, подойдет реализация в виде списка пар.

Кроме этого в каждом из вариантов требуется определить дополнительную функцию (см. задание для конкретного варианта).

Во второй задаче двоичная куча определяется как список элементов, в котором на вершине кучи находится элемент с индексом 0 (первый элемент списка - наименьший элемент), а непосредственные потомки каждого элемента с индексом k есть элементы с индексами (2k+1) и (2k+2), если, конечно, таковые имеются. Как и положено в двоичной куче, все потомки каждого элемента больше или равны этому элементу.
data BinHeap e = BinHeap [e]
В заданных условиях во второй задаче каждого варианта требуется описать одну из функций обработки двоичной кучи.


Написать функцию removeBy :: (k -> Bool) -> Map k v -> Map k v, которая удаляет из заданного отображения те пары, ключи которых удовлетворяют критерию, заданному первым аргументом функции. Например, вызов removeBy (<0) m  удалит из отображения m  те пары, ключи которых меньше нуля.

Написать функцию change :: Ord e => Int -> e -> BinHeap e -> BinHeap e, которая меняет в куче значение с заданным индексом (первый аргумент) на новое, заведомо меньшее значение (второй аргумент) и выдает модифицированную кучу.
