Ориентированный нагруженный граф с целыми значениями нагрузки на дугах графа представлен списками смежности: type Graph = [[(Int,Integer)]].
Длина списка определяет количество вершин графа, занумерованных, начиная от 0. i-й элемент списка представляет список пар из номеров вершин,
в которые ведут дуги, исходящие из вершины номер i, и нагрузки на эту дугу. Предполагается, что нагрузки на всех дугах неотрицательные.
Например, граф, представляющий простой контур из 4-х вершин, такой, что нагрузка на каждую дугу этого контура равна 10,
будет представлен структурой g = [[(1,10)],[(2,10)],[(3,10)],[(0,10)]]. Написать функцию dijkstra :: Int -> Int -> Graph -> Maybe [Int],
которая ищет путь с минимальной суммарной нагрузкой между двумя заданными вершинами в графе (если такой путь существует).
Предлагается для решения задачи реализовать алгоритм Дейкстры.
Так, например, для указанного графа функция dijkstra 1 3 g должна выдать значение Just [1,2,3].

Сетью называется связный ориентированный нагруженный граф, в котором есть две выделенные вершины - исток и сток,
и в котором выполнено условие на нагрузки: для любой вершины кроме истока и стока сумма нагрузок на входящих в вершину дугах равна сумме нагрузок на исходящих дугах.
Значения всех нагрузок считаем неотрицательными. Вершины сети занумерованы натуральными числами, начиная от нуля.
Нагруженный орграф представлен типом данных type Graph = (Int, Int->Int->Integer), где первый элемент кортежа представляет число вершин графа,
а второй элемент - функция, определяющая величину нагрузки на дуге, соединяющей вершины с заданными номерами. Если дуга отсутствует,
то полагаем, что величина нагрузки на ней равна нулю. Требуется написать функцию isNet :: Graph -> Bool, которая проверяет,
что заданный граф действительно является сетью, то есть в графе можно выделить исток и сток, и на остальных вершинах выполнено условие нулевой суммы.
Величины нагрузок предполагаются заведомо неотрицательными, проверять это специально не нужно.

